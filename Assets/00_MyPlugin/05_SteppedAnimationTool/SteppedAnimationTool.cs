#if (UNITY_EDITOR) 

using System.Collections.Generic;
using System.IO;
using Unity.Mathematics;
using UnityEditor;
using UnityEngine;
using UnityEngine.Serialization;

namespace SteppedAnimation
{
    [CreateAssetMenu(fileName = "steppedAnimation", menuName = "CustomTools/Stepped Animation")]
    public class SteppedAnimationTool : ScriptableObject
    {
        [SerializeField]
        [Tooltip("The source clips to use.")]
        public List<AnimationClip> SourceClips;

        public string AutoGeneratedName(string clipName) => clipName + "_stepped";
        
        [SerializeField]
        [Tooltip("Try to fix the generated clips' rotation interpolations? ")]
        public bool FixRotationInterpolations = true;

        [SerializeField]
        [Tooltip("How should generated keyframes be placed?")]
        public StepMode KeyframeMode = StepMode.FixedRate;

        [SerializeField]
        [Tooltip("Rate at which automatic keyframes occur.")]
        [Range(0.1f, 120f)]
        public float KeyframeRate;
        
        [SerializeField]
        [Tooltip("Times to generate keyframes for.")]
        public List<float> ManualKeyframeTimes;
        
        [SerializeField]
        [Tooltip("Frames to generate keyframes for.")]
        public List<float> ManualKeyframes;
        
        [SerializeField]
        [Tooltip("The number of frames will be played in one second.")]
        public int SampleRate = 30;
        
        public enum StepMode
        {
            FixedRate,
            FixedTimeDelay,
            ManualTime,
            ManualFrame
        }

        public float FixedTimeDelay = 0.1f;

        public List<float> GetKeyframeTimes(AnimationClip source)
        {
            int number;
            List<float> times;
            switch (KeyframeMode)
            {
                
                case StepMode.FixedRate:
                    number = (int)(source.length * KeyframeRate);
                    times = new List<float>();
                    for (int i = 0; i <= number; i++)
                        times.Add(i / KeyframeRate);
                    return times;
                
                case StepMode.FixedTimeDelay:
                    number = (int)(source.length / FixedTimeDelay);
                    times = new List<float>();
                    for (int i = 0; i <= number; i++)
                        times.Add(i * FixedTimeDelay);
                    return times;
                
                case StepMode.ManualTime:
                    return ManualKeyframeTimes;
                
                case StepMode.ManualFrame:
                    times = new List<float>();
                    for (int i = 0; i < ManualKeyframes.Count; i++)
                        times.Add(ManualKeyframes[i] / SampleRate);
                    return times;
                
                default:
                    throw new System.Exception("Unhandled mode");
            }
        }

        public void Generate()
        {
            foreach (AnimationClip clip in SourceClips)
            {
                if (clip == null)
                    continue;
                Generate(clip);
            }
        }
        
        public const string STEPPED = "Stepped";
        public void Generate(AnimationClip sourceClip)
        {
            //复制并生成新的AnimationClip
            var sourcePath = AssetDatabase.GetAssetPath(sourceClip);
            var stepPath = AssetDatabase.GetAssetPath(this);
            var outputDir = stepPath.Substring(0, stepPath.LastIndexOf('/'));
            var outputPath = outputDir + "/" + AutoGeneratedName(sourceClip.name) + ".anim";

            //如果不存在的话则生成新的文件，如果存在则进行文件数据替换复制
            if (AssetDatabase.LoadAssetAtPath<AnimationClip>(outputPath) == null)
                AssetDatabase.CreateAsset(Instantiate(sourceClip), outputPath);
            else
                File.Copy(sourcePath, outputPath, true);

            AnimationClip generatedClip = AssetDatabase.LoadAssetAtPath<AnimationClip>(outputPath);
            
            generatedClip.name = AutoGeneratedName(sourceClip.name);
            
            //给动画文件添加“Stepped”标签
            var labels = new List<string>(AssetDatabase.GetLabels(generatedClip));
            if (!labels.Contains(STEPPED))
                labels.Add(STEPPED);
            AssetDatabase.SetLabels(generatedClip, labels.ToArray());

            //获取需要采样的时间点
            var sampleTimes = GetKeyframeTimes(sourceClip);

            // 重新采样并且剔除插值平滑后，重新生成所有的动画曲线
            foreach (var binding in AnimationUtility.GetCurveBindings(sourceClip))
            {
                var sourceCurve = AnimationUtility.GetEditorCurve(sourceClip, binding);
                var generatedCurve = AnimationUtility.GetEditorCurve(generatedClip, binding);
                
                // 清除所有关键帧
                for (int i = generatedCurve.length -1; i>=0; i--)
                    generatedCurve.RemoveKey(i);
                
                for (int i = 0; i < sampleTimes.Count; i++)
                {
                    float time = sampleTimes[i];
                    time = Mathf.Clamp(time, 0f, sourceClip.length);//确保时间在0至动画长度之间

                    Keyframe key = new Keyframe(
                        sampleTimes[i],
                        sourceCurve.Evaluate(time),
                        float.NegativeInfinity,
                        float.PositiveInfinity,
                        0f,
                        0f
                        );
                    generatedCurve.AddKey(key);
                }
                
                AnimationUtility.SetEditorCurve(generatedClip, binding, generatedCurve);
            }
            
            Debug.Log("动画阶梯化完成");

            if (FixRotationInterpolations)
            {
                FixClipRotationInterpolations(ref generatedClip);
                Debug.Log("曲线插值修复完成: " + sourceClip.name);
            }
            
            AssetDatabase.SaveAssets();
        }
        
        private void FixClipRotationInterpolations(ref AnimationClip sourceClip)
        {
            EditorCurveBinding[] bindings = AnimationUtility.GetCurveBindings(sourceClip);
            List<EditorCurveBinding> rotationBindings = new List<EditorCurveBinding>();
            List<AnimationCurve> rotationCurves = new List<AnimationCurve>();

            // 收集所有旋转曲线
            foreach (var binding in bindings)
            {
                if (binding.propertyName .Contains("m_LocalRotation") )
                {
                    //Debug.Log(binding.propertyName);
                    AnimationCurve curve = AnimationUtility.GetEditorCurve(sourceClip, binding);
                    rotationBindings.Add(binding);
                    rotationCurves.Add(curve);
                }
            }

            // 删除原始旋转曲线
            foreach (var binding in rotationBindings)
            {
                AnimationUtility.SetEditorCurve(sourceClip, binding, null);
            }
            
            // 为每个旋转曲线创建欧拉角曲线
            for (int i = 0; i < rotationBindings.Count; i++)
            {
                if (rotationBindings[i].propertyName == "m_LocalRotation.x")
                {
                    EditorCurveBinding bindingX = rotationBindings[i];
                    EditorCurveBinding bindingY= rotationBindings[i+1];
                    EditorCurveBinding bindingZ= rotationBindings[i+2];
                    EditorCurveBinding bindingW= rotationBindings[i+3];
                    AnimationCurve curveX = rotationCurves[i];
                    AnimationCurve curveY = rotationCurves[i+1];
                    AnimationCurve curveZ = rotationCurves[i+2];
                    AnimationCurve curveW = rotationCurves[i+3];
                    FixRotations(ref curveX, ref curveY, ref curveZ, ref curveW);
                    AnimationUtility.SetEditorCurve(sourceClip, bindingX, curveX);
                    AnimationUtility.SetEditorCurve(sourceClip, bindingY, curveY);
                    AnimationUtility.SetEditorCurve(sourceClip, bindingZ, curveZ);
                    AnimationUtility.SetEditorCurve(sourceClip, bindingW, curveW);
                }
            }
        }
        static void FixRotations(ref AnimationCurve rotX, ref AnimationCurve rotY, ref AnimationCurve rotZ, ref AnimationCurve rotW) 
        {
            var prev = new quaternion(
                rotX.keys[0].value,
                rotY.keys[0].value,
                rotZ.keys[0].value,
            rotW.keys[0].value
            );
            for (var i = 1; i < rotX.keys.Length; i++) 
            {
                var keyX = rotX.keys[i];
                var keyY = rotY.keys[i];
                var keyZ = rotZ.keys[i];
                var keyW = rotW.keys[i];
                var value = new quaternion(
                    keyX.value,
                    keyY.value,
                    keyZ.value,
                    keyW.value
                );

                if (math.dot(prev, value) < 0) {
                    value.value = -value.value;

                    keyX.value = -keyX.value;
                    rotX.MoveKey(i, keyX);
                
                    keyY.value = -keyY.value;
                    rotY.MoveKey(i, keyY);
                
                    keyZ.value = -keyZ.value;
                    rotZ.MoveKey(i, keyZ);
                
                    keyW.value = -keyW.value;
                    rotW.MoveKey(i, keyW);
                }
                prev = value;
            }
        }
    
    }
}

 #endif